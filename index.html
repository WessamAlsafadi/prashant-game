<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodge 'n Score - Web Edition</title>
    <link rel="stylesheet" href="style.css">
  <style>
    /* Basic reset and background */
body {
    margin: 0;
    background-color: #1a1a1a; /* Dark background */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Consolas', 'Courier New', monospace;
    color: white;
    overflow: hidden; /* Hide scrollbars */
}

/* The game canvas */
canvas {
    background-color: black;
    border: 3px solid white;
}

/* The game over screen container */
#gameOverScreen {
    position: absolute; /* Puts it on top of the canvas */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black */
    width: 100%;
    height: 100%;
}

#gameOverScreen h1 {
    font-size: 5em;
    color: red;
    margin: 0;
}

#gameOverScreen p {
    font-size: 2em;
}

#restartButton {
    padding: 15px 30px;
    font-size: 1.5em;
    background-color: white;
    color: black;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    transition: transform 0.2s;
}

#restartButton:hover {
    transform: scale(1.1);
}

/* A helper class to hide elements */
.hidden {
    display: none !important;
}
  </style>
</head>
<body>
    <!-- This is where the game will be drawn -->
    <canvas id="gameCanvas"></canvas>

    <!-- This is the game over screen, hidden by default -->
    <div id="gameOverScreen" class="hidden">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <!-- We link the JavaScript file at the end so it runs after the page is loaded -->
    <script>
      // --- 1. SETUP & DOM REFERENCES ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d'); // The "context" is our tool for drawing

const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreEl = document.getElementById('finalScore');
const restartButton = document.getElementById('restartButton');

// --- CONSTANTS ---
const SCREEN_WIDTH = 800;
const SCREEN_HEIGHT = 600;
const PLAYER_SIZE = 50;
const OBJECT_SIZE = 30;

// Colors
const PLAYER_COLOR = '#00FF00'; // Green
const OBSTACLE_COLOR = '#FF0000'; // Red
const TARGET_COLOR = '#FFD700'; // Gold

// Set canvas dimensions
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

// --- GAME STATE VARIABLES ---
// We use `let` because these will change during the game
let player, keys, obstacles, targets, score, hearts, gameOver;
let gameSpeed, spawnTimer, spawnInterval;

// --- 2. GAME FUNCTIONS ---

/**
 * Resets all game variables to their initial state and starts the game.
 */
function init() {
    // Player object
    player = {
        x: SCREEN_WIDTH / 2 - PLAYER_SIZE / 2,
        y: SCREEN_HEIGHT - PLAYER_SIZE - 20,
        width: PLAYER_SIZE,
        height: PLAYER_SIZE,
        speed: 7
    };

    // Keyboard state
    keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false
    };

    // Arrays to hold our falling objects
    obstacles = [];
    targets = [];

    // Game stats
    score = 0;
    hearts = 3;
    gameOver = false;
    
    // Difficulty
    gameSpeed = 3;
    spawnTimer = 0;
    spawnInterval = 1000; // Spawn an object every 1000ms (1 second) initially

    // Hide the game over screen
    gameOverScreen.classList.add('hidden');

    // Start the game loop
    gameLoop();
}

/**
 * Handles keyboard input for smooth movement.
 */
window.addEventListener('keydown', (e) => {
    if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = true;
    }
});
window.addEventListener('keyup', (e) => {
    if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = false;
    }
});
restartButton.addEventListener('click', init);

/**
 * The main game loop, which updates and draws the game continuously.
 * `requestAnimationFrame` is a browser feature for smooth animations.
 */
let lastTime = 0;
function gameLoop(timestamp = 0) {
    if (gameOver) {
        // Show the game over screen
        finalScoreEl.textContent = score;
        gameOverScreen.classList.remove('hidden');
        return; // Stop the loop
    }
    
    // Calculate delta time for consistent speed on all computers
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    // Clear the entire canvas for the new frame
    ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    // --- UPDATE GAME LOGIC ---
    updatePlayer();
    updateObjects(deltaTime);
    checkCollisions();

    // --- DRAW EVERYTHING ---
    drawPlayer();
    drawObjects();
    drawStats();

    // Request the next frame
    requestAnimationFrame(gameLoop);
}

/**
 * Updates the player's position based on keyboard input.
 */
function updatePlayer() {
    if (keys.ArrowLeft && player.x > 0) player.x -= player.speed;
    if (keys.ArrowRight && player.x < SCREEN_WIDTH - player.width) player.x += player.speed;
    if (keys.ArrowUp && player.y > 0) player.y -= player.speed;
    if (keys.ArrowDown && player.y < SCREEN_HEIGHT - player.height) player.y += player.speed;
}

/**
 * Spawns, moves, and cleans up objects.
 */
function updateObjects(deltaTime) {
    // Spawning logic
    spawnTimer += deltaTime;
    if (spawnTimer > spawnInterval) {
        spawnTimer = 0;
        const spawnX = Math.random() * (SCREEN_WIDTH - OBJECT_SIZE);
        
        // Randomly decide whether to spawn a target or an obstacle
        if (Math.random() < 0.7) { // 70% chance for an obstacle
            obstacles.push({ x: spawnX, y: -OBJECT_SIZE, width: OBJECT_SIZE, height: OBJECT_SIZE });
        } else { // 30% chance for a target
            targets.push({ x: spawnX, y: -OBJECT_SIZE, width: OBJECT_SIZE, height: OBJECT_SIZE });
        }
    }

    // Move objects down the screen
    [...obstacles, ...targets].forEach(obj => {
        obj.y += gameSpeed;
    });

    // Difficulty scaling: get faster and spawn more often as score increases
    gameSpeed = 3 + Math.floor(score / 5);
    spawnInterval = Math.max(200, 1000 - score * 10); // Don't let spawn rate get too crazy

    // Remove objects that go off-screen
    obstacles = obstacles.filter(obj => obj.y < SCREEN_HEIGHT);
    targets = targets.filter(obj => obj.y < SCREEN_HEIGHT);
}

/**
 * Checks for collisions between the player and objects.
 */
function checkCollisions() {
    // Check collisions with obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obj = obstacles[i];
        if (isColliding(player, obj)) {
            hearts--;
            obstacles.splice(i, 1); // Remove the obstacle
            if (hearts <= 0) {
                gameOver = true;
            }
        }
    }
    
    // Check collisions with targets
    for (let i = targets.length - 1; i >= 0; i--) {
        const obj = targets[i];
        if (isColliding(player, obj)) {
            score++;
            targets.splice(i, 1); // Remove the target
        }
    }
}

/**
 * Helper function for AABB (Axis-Aligned Bounding Box) collision detection.
 */
function isColliding(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

// --- DRAWING FUNCTIONS ---

function drawPlayer() {
    ctx.fillStyle = PLAYER_COLOR;
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawObjects() {
    ctx.fillStyle = OBSTACLE_COLOR;
    obstacles.forEach(obj => ctx.fillRect(obj.x, obj.y, obj.width, obj.height));

    ctx.fillStyle = TARGET_COLOR;
    targets.forEach(obj => ctx.fillRect(obj.x, obj.y, obj.width, obj.height));
}

function drawStats() {
    ctx.fillStyle = 'white';
    ctx.font = '30px "Courier New"';
    ctx.fillText(`Score: ${score}`, 20, 40);
    ctx.fillText(`Hearts: ${hearts}`, SCREEN_WIDTH - 150, 40);
}

// --- 3. START THE GAME ---
init();
    </script>
</body>
</html>
